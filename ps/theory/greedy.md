# Greedy method
재귀 호출과 비슷하게 여러 개의 작은 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어 간다는 점은 완탐이나 DP와 다를 것이 없다.

하지만 모든 선택지를 고려하고 전체 답이 가장 좋은 것을 찾는 게 아닌 **각 단계에서 가장 좋은 방법**만을 선텍.

Greedy method가 사용되는 경우는 크게 2가지로 제한됨
* **항상 최적해**를 구할 수 있는 문제를 만난 경우
* 시간이나 공간적 제약으로 인해 **근사해**를 찾을 경우 (ps에서는 근사해를 찾는 문제가 잘 나오지 않음)

탐욕법은 보통 문제를 해결하는 방법이 한가지만 있을 경우가 많지 않으며 이 중 어느 방법을 선택해야 최적해를 구할 수 있을 지를 알아내기가 어렵다.

**So, 알고리즘의 정당성을 증명하는 과정을 빼먹으면 안됨**

<br>

## 에제: 회의실 예약
활동 선택 문제(activity selection problem)으로 회의실이 하나 밖에 없는 데 여러 팀이 각각 회의하고 싶을 때 겹치지 않고 예약할 수 있는 회의는 최대 몇개인가??

### 무식하게?
모든 부분 집합을 생각한다고 했을 때 집합의 크기는 2^n이 되기 때문에 풀기 힘듬

### 탐욕적 알고리즘 구상
짧은 회의(오름차순)순으로 생각하기 >> 367p 처럼 반례가 있음

**솔루션은 길이에 상관없이 가장 먼저 끝나는 회의부터 선택하는 것**

* 목록 S에 남은 회의 중에서 가장 일찍 끝나는회의 s<sub>min 을 선택한다.
* s<sub>min 과 겹치는 회의를 S에서 지운다.
* S가 빌 때까지 반복

<br>

## 정당성의 증명: 탐욕적 선택 속성
탐욕적 알고리즘의 정당성 증명은 많은 경우 일정한 패턴을 가짐. 이 증명 패턴은 2가지 속성을 증명하면 된다.
* 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있다.  >> **탐욕적 선택 속성(greedy choice property)**, 이 증명은 대개 우리가 선택한 답과 다른 최적해가 존재함을 가정하고, 이것을 조작해서 우리가 선택한 답을 포함하는 최적해로 바꿀 수 있음을 보이는 형태로 이루어짐
* 항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음을 보여야 함 >> **최적 부분 구조(optimal substructure)**

<br>

## Tips
* 정렬을 많이 사용한다.
* 간단한 입력을 몇 개 손으로 풀어보면서 패턴을 찾기